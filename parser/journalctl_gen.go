
package parser

// Autogenerated code from journal_profile.json. Do not edit.

import (
    "encoding/binary"
    "fmt"
    "bytes"
    "io"
    "sort"
    "strings"
    "unicode/utf16"
    "unicode/utf8"
)

var (
   // Depending on autogenerated code we may use this. Add a reference
   // to shut the compiler up.
   _ = bytes.MinRead
   _ = fmt.Sprintf
   _ = utf16.Decode
   _ = binary.LittleEndian
   _ = utf8.RuneError
   _ = sort.Strings
   _ = strings.Join
   _ = io.Copy
)

func indent(text string) string {
    result := []string{}
    lines := strings.Split(text,"\n")
    for _, line := range lines {
         result = append(result, "  " + line)
    }
    return strings.Join(result, "\n")
}


type JournalProfile struct {
    Off_CompatDataObject_payload int64
    Off_CompatEntryItem_object int64
    Off_DataObject_payload int64
    Off_EntryItem_object int64
    Off_EntryObject_seqnum int64
    Off_EntryObject_realtime int64
    Off_EntryObject_monotonic int64
    Off_FileHeader_Signature int64
    Off_FileHeader_compatible_flags int64
    Off_FileHeader_incompatible_flags int64
    Off_FileHeader_header_size int64
    Off_FileHeader_arena_size int64
    Off_FileHeader_n_objects int64
    Off_FileHeader_n_entries int64
    Off_FileHeader_tail_entry_seqnum int64
    Off_ObjectHeader_Type int64
    Off_ObjectHeader_flags int64
    Off_ObjectHeader___real_size int64
}

func NewJournalProfile() *JournalProfile {
    // Specific offsets can be tweaked to cater for slight version mismatches.
    self := &JournalProfile{56,0,48,0,0,8,16,0,8,12,88,96,144,152,160,0,1,8}
    return self
}

func (self *JournalProfile) CompatDataObject(reader io.ReaderAt, offset int64) *CompatDataObject {
    return &CompatDataObject{Reader: reader, Offset: offset, Profile: self}
}

func (self *JournalProfile) CompatEntryItem(reader io.ReaderAt, offset int64) *CompatEntryItem {
    return &CompatEntryItem{Reader: reader, Offset: offset, Profile: self}
}

func (self *JournalProfile) DataObject(reader io.ReaderAt, offset int64) *DataObject {
    return &DataObject{Reader: reader, Offset: offset, Profile: self}
}

func (self *JournalProfile) EntryItem(reader io.ReaderAt, offset int64) *EntryItem {
    return &EntryItem{Reader: reader, Offset: offset, Profile: self}
}

func (self *JournalProfile) EntryObject(reader io.ReaderAt, offset int64) *EntryObject {
    return &EntryObject{Reader: reader, Offset: offset, Profile: self}
}

func (self *JournalProfile) FileHeader(reader io.ReaderAt, offset int64) *FileHeader {
    return &FileHeader{Reader: reader, Offset: offset, Profile: self}
}

func (self *JournalProfile) ObjectHeader(reader io.ReaderAt, offset int64) *ObjectHeader {
    return &ObjectHeader{Reader: reader, Offset: offset, Profile: self}
}


type CompatDataObject struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *CompatDataObject) Size() int {
    return 0
}


func (self *CompatDataObject) payload() string {
  return ParseTerminatedString(self.Reader, self.Profile.Off_CompatDataObject_payload + self.Offset)
}
func (self *CompatDataObject) DebugString() string {
    result := fmt.Sprintf("struct CompatDataObject @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  payload: %v\n", string(self.payload()))
    return result
}

type CompatEntryItem struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *CompatEntryItem) Size() int {
    return 4
}

func (self *CompatEntryItem) object() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_CompatEntryItem_object + self.Offset)
}
func (self *CompatEntryItem) DebugString() string {
    result := fmt.Sprintf("struct CompatEntryItem @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  object: %#0x\n", self.object())
    return result
}

type DataObject struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *DataObject) Size() int {
    return 0
}


func (self *DataObject) payload() string {
  return ParseTerminatedString(self.Reader, self.Profile.Off_DataObject_payload + self.Offset)
}
func (self *DataObject) DebugString() string {
    result := fmt.Sprintf("struct DataObject @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  payload: %v\n", string(self.payload()))
    return result
}

type EntryItem struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *EntryItem) Size() int {
    return 16
}

func (self *EntryItem) object() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_EntryItem_object + self.Offset)
}
func (self *EntryItem) DebugString() string {
    result := fmt.Sprintf("struct EntryItem @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  object: %#0x\n", self.object())
    return result
}

type EntryObject struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *EntryObject) Size() int {
    return 48
}

func (self *EntryObject) seqnum() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_EntryObject_seqnum + self.Offset)
}

func (self *EntryObject) realtime() int64 {
    return ParseInt64(self.Reader, self.Profile.Off_EntryObject_realtime + self.Offset)
}

func (self *EntryObject) monotonic() int64 {
    return ParseInt64(self.Reader, self.Profile.Off_EntryObject_monotonic + self.Offset)
}
func (self *EntryObject) DebugString() string {
    result := fmt.Sprintf("struct EntryObject @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  seqnum: %#0x\n", self.seqnum())
    result += fmt.Sprintf("  realtime: %#0x\n", self.realtime())
    result += fmt.Sprintf("  monotonic: %#0x\n", self.monotonic())
    return result
}

type FileHeader struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *FileHeader) Size() int {
    return 0
}


func (self *FileHeader) Signature() string {
  return ParseString(self.Reader, self.Profile.Off_FileHeader_Signature + self.Offset, 8)
}

func (self *FileHeader) compatible_flags() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_FileHeader_compatible_flags + self.Offset)
}

func (self *FileHeader) incompatible_flags() *Flags {
   value := ParseUint32(self.Reader, self.Profile.Off_FileHeader_incompatible_flags + self.Offset)
   names := make(map[string]bool)


   if value & (1 << 0) != 0 {
      names["COMPRESSED_XZ"] = true
   }

   if value & (1 << 1) != 0 {
      names["COMPRESSED_LZ4"] = true
   }

   if value & (1 << 2) != 0 {
      names["KEYED_HASH"] = true
   }

   if value & (1 << 3) != 0 {
      names["COMPRESSED_ZSTD"] = true
   }

   if value & (1 << 4) != 0 {
      names["COMPACT"] = true
   }

   return &Flags{Value: uint64(value), Names: names}
}


func (self *FileHeader) header_size() int64 {
    return ParseInt64(self.Reader, self.Profile.Off_FileHeader_header_size + self.Offset)
}

func (self *FileHeader) arena_size() int64 {
    return ParseInt64(self.Reader, self.Profile.Off_FileHeader_arena_size + self.Offset)
}

func (self *FileHeader) n_objects() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_FileHeader_n_objects + self.Offset)
}

func (self *FileHeader) n_entries() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_FileHeader_n_entries + self.Offset)
}

func (self *FileHeader) tail_entry_seqnum() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_FileHeader_tail_entry_seqnum + self.Offset)
}
func (self *FileHeader) DebugString() string {
    result := fmt.Sprintf("struct FileHeader @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  Signature: %v\n", string(self.Signature()))
    result += fmt.Sprintf("  compatible_flags: %#0x\n", self.compatible_flags())
    result += fmt.Sprintf("  incompatible_flags: %v\n", self.incompatible_flags().DebugString())
    result += fmt.Sprintf("  header_size: %#0x\n", self.header_size())
    result += fmt.Sprintf("  arena_size: %#0x\n", self.arena_size())
    result += fmt.Sprintf("  n_objects: %#0x\n", self.n_objects())
    result += fmt.Sprintf("  n_entries: %#0x\n", self.n_entries())
    result += fmt.Sprintf("  tail_entry_seqnum: %#0x\n", self.tail_entry_seqnum())
    return result
}

type ObjectHeader struct {
    Reader io.ReaderAt
    Offset int64
    Profile *JournalProfile
}

func (self *ObjectHeader) Size() int {
    return 16
}

func (self *ObjectHeader) Type() *Enumeration {
   value := ParseUint8(self.Reader, self.Profile.Off_ObjectHeader_Type + self.Offset)
   name := "Unknown"
   switch value {

      case 0:
         name = "OBJECT_UNUSED"

      case 1:
         name = "OBJECT_DATA"

      case 2:
         name = "OBJECT_FIELD"

      case 3:
         name = "OBJECT_ENTRY"

      case 4:
         name = "OBJECT_DATA_HASH_TABLE"

      case 5:
         name = "OBJECT_FIELD_HASH_TABLE"

      case 6:
         name = "OBJECT_ENTRY_ARRAY"

      case 7:
         name = "OBJECT_TAG"
}
   return &Enumeration{Value: uint64(value), Name: name}
}


func (self *ObjectHeader) flags() byte {
   return ParseUint8(self.Reader, self.Profile.Off_ObjectHeader_flags + self.Offset)
}

func (self *ObjectHeader) __real_size() int64 {
    return ParseInt64(self.Reader, self.Profile.Off_ObjectHeader___real_size + self.Offset)
}
func (self *ObjectHeader) DebugString() string {
    result := fmt.Sprintf("struct ObjectHeader @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  Type: %v\n", self.Type().DebugString())
    result += fmt.Sprintf("  flags: %#0x\n", self.flags())
    result += fmt.Sprintf("  __real_size: %#0x\n", self.__real_size())
    return result
}

type Enumeration struct {
    Value uint64
    Name  string
}

func (self Enumeration) DebugString() string {
    return fmt.Sprintf("%s (%d)", self.Name, self.Value)
}


type Flags struct {
    Value uint64
    Names  map[string]bool
}

func (self Flags) DebugString() string {
    names := []string{}
    for k, _ := range self.Names {
      names = append(names, k)
    }

    sort.Strings(names)

    return fmt.Sprintf("%d (%s)", self.Value, strings.Join(names, ","))
}

func (self Flags) IsSet(flag string) bool {
    result, _ := self.Names[flag]
    return result
}

func (self Flags) Values() []string {
    result := make([]string, 0, len(self.Names))
    for k, _ := range self.Names {
       result = append(result, k)
    }
    return result
}


func ParseInt64(reader io.ReaderAt, offset int64) int64 {
	var buf [8]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return int64(binary.LittleEndian.Uint64(data))
}

func ParseUint32(reader io.ReaderAt, offset int64) uint32 {
	var buf [4]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint32(data)
}

func ParseUint64(reader io.ReaderAt, offset int64) uint64 {
	var buf [8]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint64(data)
}

func ParseUint8(reader io.ReaderAt, offset int64) byte {
	var buf [1]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return data[0]
}

func ParseTerminatedString(reader io.ReaderAt, offset int64) string {
   var buf [1024]byte
   data := buf[:]
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }
   idx := bytes.Index(data[:n], []byte{0})
   if idx < 0 {
      idx = n
   }
   return string(data[0:idx])
}

func ParseString(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
      return ""
   }
   return string(data[:n])
}


